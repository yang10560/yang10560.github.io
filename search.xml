<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>垃圾回收概述</title>
      <link href="/2023/01/12/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/01/12/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master//images/JVM%E5%BA%95%E5%B1%82%E4%BD%93%E7%B3%BB.jpg"></p><h2 id="一、什么是垃圾"><a href="#一、什么是垃圾" class="headerlink" title="一、什么是垃圾"></a>一、什么是垃圾</h2><p>什么是垃圾（ Garbage） 呢？</p><p> ➢垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。<br> 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空 间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><ul><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>➢哪些内存需要回收？</li><li>➢什么时候回收？</li><li>➢如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li></ul><h2 id="二、为什么需要GC"><a href="#二、为什么需要GC" class="headerlink" title="二、为什么需要GC"></a>二、为什么需要GC</h2><ul><li><p>对于高级语言来说，一个基本认知是，如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p></li><li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。</p></li><li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p></li></ul><h2 id="三、早期的垃圾回收"><a href="#三、早期的垃圾回收" class="headerlink" title="三、早期的垃圾回收"></a>三、早期的垃圾回收</h2><ul><li>在早期的C&#x2F;C++时代，垃圾回收基本.上是手工进行的。开发人员可以使用</li></ul><p>new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>()；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> （pBridge-&gt;Register（kDestroy）！= NO_ERROR）</span><br><span class="line"><span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure><ul><li>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来&#x3D;&#x3D;频繁申请和释放内存的管理负担&#x3D;&#x3D;。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</li><li>在有了垃圾回收机制后，上述代码块极有可能变成这样：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>()；</span><br><span class="line">pBridge -&gt; <span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure><ul><li>现在，除了Java以外，C#、Python、 Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</li></ul><h2 id="四、Java垃圾回收机制"><a href="#四、Java垃圾回收机制" class="headerlink" title="四、Java垃圾回收机制"></a>四、Java垃圾回收机制</h2><ul><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li><li><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p></li><li><p>此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</p></li><li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p></li><li><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p><ul><li>其中，Java堆是垃圾收集器的工作重点。</li><li>从次数上讲：<ul><li>频繁收集Young区</li><li>较少收集0ld区</li><li>基本不动Perm区(方法区)</li></ul></li></ul></li><li><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703093933143.png" alt="image-20210703093933143"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 辣鸡 </tag>
            
            <tag> 回收 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/12/hello-world/"/>
      <url>/2023/01/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="/2022/10/21/My-New-Post/"/>
      <url>/2022/10/21/My-New-Post/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><pre><code>JVM虚拟机规范中曾经试图定义一种Java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都可以达到一致性的内存访问效果。然而定义这样一套内存模型并非很容易，这个模型必须足够严谨，才能让Java的并发内存访问操作不会有歧义。但是也必须足够宽松，这样使得虚拟机的具体实现能够有自由的发挥空间来利用各种硬件的优势。经过长时间的验证和弥补，到了JDK1.5（实现了JSR133规范）之后，Java内存模型才终于成熟起来了。</code></pre><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><pre><code>Java内存模型规定了所有的变量都存储在`主内存`(Main Memory)中，每条线程都有自己的`工作内存`（Work Memory）</code></pre><ul><li>工作内存中保存了被该线程使用的变量的主内存副本，</li><li>线程对变量的读写操作必须在工作内存中进行。</li><li>而不能直接访问主内存的数据。</li><li>不同的线程也不能互相读写对方的工作内存，线程之间的变量传递必须通过主内存传递。</li></ul><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master//images/image-20210731210337786.png" alt="image-20210731210337786"></p><h2 id="主内存和工作内存的交互"><a href="#主内存和工作内存的交互" class="headerlink" title="主内存和工作内存的交互"></a>主内存和工作内存的交互</h2><h3 id="Java内存模型定义了如下八种操作-每一种操作都是原子的，不可再分的"><a href="#Java内存模型定义了如下八种操作-每一种操作都是原子的，不可再分的" class="headerlink" title="Java内存模型定义了如下八种操作(每一种操作都是原子的，不可再分的)"></a>Java内存模型定义了如下八种操作(每一种操作都是<code>原子的</code>，<code>不可再分</code>的)</h3><ul><li><code>lock 锁定</code>： 作用于主内存，将一个变量标识为线程独占状态</li><li><code>unlock: 解锁</code> ： 作用于主内存，将一个线程独占状态的变量释放</li><li><code>read 读取</code> ： 从主内存读取数据到工作内存，便于之后的load操作</li><li><code>load 载入</code>：  把read读取操作从主内存中得到的变量放入工作内存的变量副本中</li><li><code>use 使用</code>： 将工作内存中的变量传递给执行引擎   当虚拟机遇到一个需要使用变量值的字节码时，执行此操作</li><li><code>assign赋值</code>： 将执行引擎中的值赋给工作内存的变量。 当虚拟机遇到一个赋值操作时，执行此操作</li><li><code>store存储</code>： 将工作内存的值传递到主内存 ，便于之后的write操作</li><li><code>write写入</code>：将store存储操作中从工作内存中获取的变量写入到主内存中</li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><ul><li>如果要把一个变量从主内存拷贝到工作内存，则依次执行read读取操作, load载入操作</li><li>如果要把一个变量从工作内存写入到主内存，则依次执行store存储操作，write写入操作</li></ul><h3 id="上述的8种操作必须满足以下规则："><a href="#上述的8种操作必须满足以下规则：" class="headerlink" title="上述的8种操作必须满足以下规则："></a>上述的8种操作必须满足以下规则：</h3><ul><li>不允许read和load、store和write操作之一单独出现。也就是说不允许一个变量从主内存读取但是工作内存不接受，也不允许工作内存发起回写请求但是主内存不接受。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h2 id="volatile特殊规则"><a href="#volatile特殊规则" class="headerlink" title="volatile特殊规则"></a>volatile特殊规则</h2><pre><code>volatile可以说是Java虚拟机提供的最轻量级的同步机制。但是它并不容易被正确，完整的理解。Java内存模型中规定当一个变量被定义为`volatile`之后，表示着线程工作内存无效，对此值的读写操作都会直接作用在主内存上，</code></pre><p>因此它具备对所有线程的<code>立即可见性</code>。以及禁止执行引擎对其进行<code>指令重排序</code></p><ol><li><h3 id="保证此变量对所有线程的立即可见性"><a href="#保证此变量对所有线程的立即可见性" class="headerlink" title="保证此变量对所有线程的立即可见性"></a>保证此变量对所有线程的<code>立即可见性</code></h3><pre><code>当变量的值被修改之后，新值对于其他线程是立即可知的。普通变量并不能做到这一点，因为普通变量的值在线程之间的传递是要进过主内存来完成的。比如当线程A对变量进行了回写操作，线程B只有在A回写完成之后，在对主内存操作，新值才对B是可见的。在A回写到主内存的过程中，B读取的依旧是旧值。但是这并不可以推导出`基于volatile变量的运算在并发下是安全的`，因为在Java中的运算操作符并不是`原子性`的。这导致了`volatile变量在并发下运算是不安全`的。</code></pre><p>通过代码验证<code>volatile变量在并发下运算是不安全</code></p><p>首先我们创建20个线程，每个线程对volatile变量进行1000次的自增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者: 写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment"> * @时间: 2021/07/31</span></span><br><span class="line"><span class="comment"> * @描述: 通过代码验证 【volatile变量在并发下运算是不安全】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile修饰的count</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count自增方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对count进行递增1000次操作的可运行接口</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始对count进行递增操作&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程对count递增操作结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建20个线程并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">            thread.setName((i+<span class="number">1</span>) + <span class="string">&quot;号线程&quot;</span>);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//主线程回到就绪状态</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程结束,count = &quot;</span> + count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此程序在并发下是安全的，那么count的值最后肯定是20*1000 &#x3D; 20000；也就是说，如果运行结果为20000，那么<code>volatile变量在并发下运算是安全的</code></p><p>通过多次运行程序，我们发现，count的值永远比20000小。</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master//images/image-20210731215601479.png" alt="image-20210731215601479"></p><p>那么，这是为什么呢？</p><p>我们将上方的代码进行反编译，然后分析increment方法的字节码指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic #<span class="number">2</span> &lt;cn/shaoxiongdu/chapter6/VolatileTest.count : I&gt;</span><br><span class="line"><span class="number">3</span> iconst_1</span><br><span class="line"><span class="number">4</span> iadd</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">2</span> &lt;cn/shaoxiongdu/chapter6/VolatileTest.count : I&gt;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们可以发现，一行count++代码被分为 4行字节码文件去执行。通过对字节码的分析，我们发现，</p><p>当偏移量为0的字节码getStatic将count的值从局部变量表取到操作数栈顶的时候，<code>volatile</code>保证了此时count的值是正确的，但是在执行iconst_1, iadd这些操作的时候，其他线程已经把count的值改变了，此时，操作数栈顶的count为过期的数据，所以putStatic字节码指令就有可能将较小的值同步到主内存中。因此最终的值会比20000稍微小。</p><p>也就是说，<code>volatile变量在并发下运算是不安全的</code> 。</p><p>在并发环境下，volatile的变量只是对全部线程即时可见的，如果要进行写的操作，还是要通过加锁来解决。</p></li></ol><h2 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h2><pre><code>Java内存模型要求对上述的八种操作必须是原子性的，但是对于64位的数据类型（8字节的Long和double）在模型中特别定义了一条宽松的规定： 允许虚拟机将没有被volatile修饰的64位数据的读写划分为2次32位的操作来进行。即允许虚拟机实现自行选择是否保证64位的数据类型的load,store,read 和wirte四个操作的原子性。这就是所谓的`long和double的非原子性协定`</code></pre><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><pre><code>由Java内存模型直接保证原子性变量操作包括: read,load,assign,use,store和write 6个。我们大致可以认为，基本数据类型的访问，读写操作都是原子性的。如果场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足，尽管虚拟机未把lock和unlock的操作直接开放给用户。但是提供了更高层次的字节码指令 `monitorenter`和`monitorexit`来隐式的使用这两个操作。这两个字节码指令反映到代码层面就是`synchronized`关键字。这就是为什么`synchronized`关键字内部的操作也是原子性的。</code></pre><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><pre><code>可加性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改，对修改是可见的。Java内存模型中是以这种方式实现的: 在变量修改之后将修改的值同步回主内存，其他线程读取前将新值从主内存同步到工作内存。无论是普通变量还是`volatile`变量都是如此。只不过`volatile`保证了修改了新值能立即同步到主内存，每次读取都会从主内存同步。</code></pre><p>除了<code>volatile</code>之外，Java中还有两个关键字是可以保证可见性的。<code>synchronized</code>和<code>final</code></p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><pre><code>同步代码块可实现可见性是因为: 规定对一个变量执行unlock操作之前，必须把变量的值同步至主内存。也就是对一个变量进行解锁的时候，保证主内存中的值已经是最新的值。此时，解锁之后，别的线程从主内存进行同步，值就是正确的。</code></pre><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><pre><code>表示当final修饰的变量在构造器中一旦初始化完成，此时，不需要将`this`引用传递出去，别的线程就可以立即感知到final修饰的变量的值。</code></pre><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote><p>在Java中，如果在本线程内观察，所有的操作都是有序的。</p><p>如果在一个线程中观察另一个线程，则所有的操作都是无序的。</p></blockquote><pre><code>后半句主要是因为： `指令重排序`和`工作内存和主内存同步延迟`。</code></pre><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
